#pragma once

#include "tools/Algorithms.h"
#include "tools/Environment.h"
#include "tools/Path.h"
#include "tools/Graph.h"
#include "tools/DynamicAgent.h"
#include "HW2.h"

#include <tuple>

namespace amp {

/// @brief Derive this class and implement your algorithm in the `plan` method. 
class KinodynamicRRT : public KinodynamicMotionPlanner {
    public:
        virtual ~KinodynamicRRT() {}
};

class HW9 {
    public:
        /// @brief Get WO1 described in HW2, Exercise 2.
        /// @return Workspace 1
        static amp::KinodynamicProblem2D getStateIntProblemWS1();
        static amp::KinodynamicProblem2D getFOUniProblemWS1();
        static amp::KinodynamicProblem2D getSOUniProblemWS1();
        static amp::KinodynamicProblem2D getCarProblemWS1();

        /// @brief Get WO2 described in HW2, Exercise 2.
        /// @return Workspace 2 
        static amp::KinodynamicProblem2D getStateIntProblemWS2();
        static amp::KinodynamicProblem2D getFOUniProblemWS2();
        static amp::KinodynamicProblem2D getSOUniProblemWS2();

        /// @brief Get parallel parking problem described in Exercise 2.
        static amp::KinodynamicProblem2D getParkingProblem();

        /// @brief Checks the path generated by your motion planner against the problem
        /// @param path Path generated by your motion planner
        /// @param prob Problem that path was generated on
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool check(const amp::KinoPath& path, const amp::KinodynamicProblem2D& prob, bool verbose = true);

        /// @brief Checks the path generated by your motion planner against the problem
        /// @param path Path generated by your motion planner
        /// @param prob Problem that path was generated on
        /// @param verbose Output logs displaying result
        /// @param collision_points Gather collision points found along the path
        /// @return `true` if path is a valid solution, `false` otherwise
        // static bool check(const amp::KinoPath& path, const amp::KinodynamicProblem2D& prob, std::vector<Eigen::Vector2d>& collision_points, bool verbose = true);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// @param algo Your implemented algorithm
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(amp::KinodynamicMotionPlanner& algo, amp::DynamicAgent& agent, bool verbose = true, uint32_t seed = 0u);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// @param algo Your implemented algorithm
        /// @param path Return the path generated by your algorithm
        /// @param prob Return the randomly generated problem used
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(amp::KinodynamicMotionPlanner& algo, amp::DynamicAgent& agent, amp::KinoPath& path, amp::KinodynamicProblem2D& prob, bool verbose = true, uint32_t seed = 0u);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// @param algo Your implemented algorithm
        /// @param path Return the path generated by your algorithm
        /// @param prob Return the randomly generated problem used
        /// @param collision_points Gather collision points found along the path
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        // static bool generateAndCheck(amp::KinodynamicMotionPlanner& algo, amp::KinoPath& path, amp::KinodynamicProblem2D& prob, std::vector<Eigen::Vector2d>& collision_points, bool verbose = true, uint32_t seed = 0u);

        static int grade(KinodynamicRRT& kino_algo, DynamicAgent& si_agent, DynamicAgent& fo_agent, DynamicAgent& so_agent, DynamicAgent& car_agent,const std::string& email, int argc, char** argv);

        template <class KINO_ALG_T, class SI_AGENT_T, class FO_AGENT_T, class SO_AGENT_T, class CAR_AGENT_T>
        static int grade(const std::string& email, int argc, char** argv);

        template <class KINO_ALG_T, class SI_AGENT_T, class FO_AGENT_T, class SO_AGENT_T, class CAR_AGENT_T, class _KINO_CTOR_ARGS_TUP, 
            class _SI_CTOR_ARGS_TUP, class _FO_CTOR_ARGS_TUP, class _SO_CTOR_ARGS_TUP, class _CAR_CTOR_ARGS_TUP>
        static int grade(const std::string& email, int argc, char** argv, const _KINO_CTOR_ARGS_TUP& kino_ctor_args_tuple, const _SI_CTOR_ARGS_TUP& si_ctor_args_tuple, 
            const _FO_CTOR_ARGS_TUP& fo_ctor_args_tuple, const _SO_CTOR_ARGS_TUP& so_ctor_args_tuple, const _CAR_CTOR_ARGS_TUP& car_ctor_args_tuple);
    private:
        static void assertDerivesSamplerAlgo(amp::KinodynamicMotionPlanner& algo);
        static void assertDerivesDynamicAgent(amp::DynamicAgent& agent);
};

#define AMP_HW9_ALIAS "hw9"
#define AMP_HW9_PACKAGE_NAME "hw9_report_card"
}

#include "public/HW9_impl.h"