#pragma once

#include <memory>

#include "tools/Environment.h"
#include "tools/Obstacle.h"
#include "tools/LinkManipulator.h"
#include "tools/ConfigurationSpace.h"
#include "tools/Algorithms.h"

namespace amp {

/// @brief Gradient Descent planning algorithm. Derives a MotionPlanner2D algorithm with a "point" agent type
class GDAlgorithm : public PointMotionPlanner2D {
    public:
        virtual ~GDAlgorithm() {}
};

class HW5 {
    public:
        /// @brief Get workspace Exercies 2 part (a) 
        /// @return Workspace with two square obstacles
        static amp::Problem2D getWorkspace1();

        /// @brief Checks the path generated by the GD algorithm against the problem
        /// @param path Path generated by gradient descent algorithm
        /// @param prob Problem that path was generated on
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool check(const amp::Path2D& path, const amp::Problem2D& prob, bool verbose = true);

        /// @brief Checks the path generated by the GD algorithm against the problem
        /// @param path Path generated by gradient descent algorithm
        /// @param prob Problem that path was generated on
        /// @param verbose Output logs displaying result
        /// @param collision_points Gather collision points found along the path
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool check(const amp::Path2D& path, const amp::Problem2D& prob, std::vector<Eigen::Vector2d>& collision_points, bool verbose = true);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// NOTE: It is unlikely that a gradient descent algorithm will be able to solve any random environment,
        /// especially without tuning
        /// @param algo Your implemented GD algorithm
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(GDAlgorithm& algo, bool verbose = true, uint32_t seed = 0u);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// NOTE: It is unlikely that a gradient descent algorithm will be able to solve any random environment,
        /// especially without tuning
        /// @param algo Your implemented GD algorithm
        /// @param path Return the path generated by your algorithm
        /// @param prob Return the randomly generated problem used
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(GDAlgorithm& algo, amp::Path2D& path, amp::Problem2D& prob, bool verbose = true, uint32_t seed = 0u);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// NOTE: It is unlikely that a gradient descent algorithm will be able to solve any random environment,
        /// especially without tuning
        /// @param algo Your implemented GD algorithm
        /// @param path Return the path generated by your algorithm
        /// @param prob Return the randomly generated problem used
        /// @param collision_points Gather collision points found along the path
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(GDAlgorithm& algo, amp::Path2D& path, amp::Problem2D& prob, std::vector<Eigen::Vector2d>& collision_points, bool verbose = true, uint32_t seed = 0u);

        /// @brief Tests your algorithm on HW5 Workspace1, HW2 Workspace1, and HW2 Workspace2.
        /// NOTE: Make sure your member variables are correctly reset after each call to plan(). This method does not reconstruct the 
        /// GDAlgorithm object that you pass in
        /// @param algo Your implemented gradient descent algorithm
        /// @param email Your identikey@colorado.edu email
        /// @param argc Pass the cmd line args from main
        /// @param argv Pass the cmd line args from main
        static int grade(GDAlgorithm& algo, const std::string& email, int argc, char** argv);

        /// @brief Tests your algorithm on HW5 Workspace1, HW2 Workspace1, and HW2 Workspace2.
        /// NOTE: Reconstructs your algorithm object every trial to make sure your member variables are reset, etc...
        /// @tparam GD_ALGORITHM_T The type of your gradient descent algorithm object (MUST derive GDAlgorithm)
        /// @tparam ..._CTOR_ARGS_T [automatically deduced] Constructor parameter arg types 
        /// @param email Your identikey@colorado.edu email
        /// @param argc Pass the cmd line args from main
        /// @param argv Pass the cmd line args from main
        /// @param constructor_arguments Pass the remaining arguments as you would to your constructor
        template <class GD_ALGORITHM_T, class... _CTOR_ARGS_T>
        static int grade(const std::string& email, int argc, char** argv, _CTOR_ARGS_T&&... constructor_arguments);
};

#define AMP_HW5_ALIAS "hw5"
#define AMP_HW5_PACKAGE_NAME "hw5_report_card"
}

#include "public/HW5_impl.h"